# Guess the Number -- Binary Exploitation

I think it's pretty nice that they've given us the code here. But before we even look at the code, let's run the binary and give that a shot. Running
```
./guess_num
``` 
gives us this:
```
Welcome to the number guessing game!
I'm thinking of a number. Can you guess it?
Guess right and you get a shell!
Enter your number: 9384 
You entered 9384. Let's see if it was right...
```

I just tried a random number, and obviously 9384 wasn't right. Oh well, let's now dive into the code. 

After opening up `guess_num.c` there are a couple interesting things to note here. Let's go through them one by one. What we're trying to do is get a high level idea of what the program is doing.

First we note the conspicuous `win` function, which seems to give us a shell, indicated by
```c
system("/bin/sh -i");
```

So it seems like, somehow, if we could call that function, we'd have what we were looking for.

Hmm...let's keep going.

We then get the print statements, so nothing *too* interesting going on over there. 

We see a `scanf`, which, if we check the man pages by going `man scanf`, which basically says, "Get the first 32 characters of what the user types in."

Then we see something a little more interesting:
```c
val = strtol(buf, NULL, 10);
```
Once again, going back to the man pages, we see that this converts `buf` (a string) to a `long int`. An important thing to note, however, is that it *does* account for overflows. If there's an underflow, it replaces it returns `LONG_MIN` and if there's an overflow, it returns `LONG_MAX`.

Finally, we see that
```c
val >>= 4;
// That's the same thing as: val = val >> 4. 
```
That means that the value is being right shifted by 4.

Still, that is fine. We are still not 100% sure what we have to do...right?

Let's move onto the next line:
```c
((void (*)(void))val)();
```
Now what in the world is going on here? All this function does is run anything you give it. 
Here's a great link on how to read such `C` declarations. It's called the *Clockwise/Spiral Rule*.
[http://c-faq.com/decl/spiral.anderson.html](http://c-faq.com/decl/spiral.anderson.html)

So looking after looking at Anderson's rule, we can try to deduce what this means:

After removing the last pair of parentheses, we observe that this is actually a function.
```c
((void (*)(void)) val)
// This is a function
```
(Elaborate further)

So, what do we want to do?

* We want to call the `win` function. The last line in the `main` method will call whatever function you give it. So, it makes sense that we want to give it the address of the `win` function, right? But remember! 

* Let's fire up GDB and take a look at where that function is located. Run GDB with 
```bash
gdb guess_num
```
and do a quick google search on how to find the memory address of a function.

We observe that the `win` function is located at 0x0804852b. We want the final value of `val` to take on value of the memory address of the win function. Let's remember, whatever value we input, it will ultimately be casted into an `unsigned long`, so we are free to input negative values as well. You should look up *twos-complement*, if this idea seems unfamiliar.Now, the number we need to input will be 0x080452b << 4, but as we know, that will result in overflow. So instead, we can input a negative number, whose binary represntation is its positive counterpart, and that in 32-bit twos complement will be -2142743888.

So, after running `./guess_num` and inputting `-2142743888`, we are given a shell.

All we have to do now is simply `cat flag.txt`, and we have our flag, which is
```
f2892be47d731c96e753d14c913fd757
```
